/*
 * $Id: DataAccessObject.java,v 1.6 2012-05-22 13:34:42 agoulart Exp $
 */
package org.utopia.efreet;

import java.io.OutputStream;
import java.io.Writer;
import java.math.BigDecimal;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.sql.Types;
import java.text.NumberFormat;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Locale;
import java.util.SortedSet;

import org.apache.log4j.Logger;
import org.utopia.common.util.ConnectionUtil;

/**
 * DAO basic class <br>
 * This is the class generated by the Factory that can be used by the BLOBs
 * to access the RDBMS.<br>
 * To use this class you must first generate an instance through the factory.
 * <br>
 * After that you must set the jdbc connection with the RDBMS.<br>
 * Then the DAO is ready to go. The following examples describe some 
 * common operations :
 * <UL>
 *   <LI>Queries - For queries you don't need to set the values of the
 * columns in the DAO. All you need is the name of the query defined in
 * the model and set the parameters as an array of Objects.</LI>
 * 
 */
public class DataAccessObject
{
    /** JDBC Connection with the RDBMS */
    protected Connection con = null;
    /** Number of records retrieved on the last query */
    protected int totalLastQuery = 0;
    /** The model of this DAO */
    protected DAOModel model = null;
    /** Data Source name */
    protected String dataSource = null;
    /** Flag que indica modo de transacao para fechar a conexao */
    protected boolean transactionMode = false; 
 
    static Logger logger = Logger.getLogger(DataAccessObject.class.getName());
    
    public Connection getConnection() {	return this.con; }
    public void setConnection(Connection connection) { this.con = connection; }
    public int getTotalLastQuery() { return this.totalLastQuery; }
    public void setTotalLastQuery(int param) { this.totalLastQuery = param; }

    public DAOModel getModel() { return this.model; }
    public void setModel(DAOModel param) { 
        this.model = param; 
        this.dataSource = this.model.getDataSource();
    }
    public String getDataSource() { return this.dataSource!=null?this.dataSource:this.model.getDataSource(); }
    public void setDataSource(String param) { this.dataSource = param; }
    
    private HashMap<String, QueryModel> conditionalQueries = null;

    private ArrayList<QueryInBatch> batchQueries = null;
    
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------

    /**
     * Sets the parameters to the prepared statement
     * @param ps prepared statement
     * @param queryObj Query object
     * @param params parameters
     */
    private void setParameters(PreparedStatement ps, QueryModel queryObj, QueryParameter params)
    	throws SQLException, Exception
    {
    	SortedSet<ParameterModel> vp = queryObj.getParameters();
    	
    	if (vp != null && params != null) {
    		for (ParameterModel model : vp) { 
    			Object thisParam = null;

    			// Static values set inside the parameter, used for conditionals
    			if (model.getStaticValue() != null) {
    				thisParam = model.getStaticValue();
    			} else
    			if (params.getParametersHash() != null && !params.getParametersHash().isEmpty()) {
    				// Hashtable style
    				thisParam = params.get(model.getParamName());
    			} else {
    				// Old - Vector style
    				thisParam = params.getParameters()[model.getParamIndex()-1];
    			}
    			if (thisParam != null) {
    				logger.trace(model  + " = " + thisParam.toString());
    				if (thisParam instanceof java.util.Date) {
    					long milis = ((java.util.Date) thisParam).getTime();
    					if (model.getParamType() == Types.TIME) {
    						Time pTm = new Time(milis);
    						ps.setTime(model.getParamIndex(), pTm);
    					} else
    						if (model.getParamType() == Types.TIMESTAMP) {
    							Timestamp pTm = new Timestamp(milis);
    							ps.setTimestamp(model.getParamIndex(), pTm);
    						} else {
    							java.sql.Date pDt = new java.sql.Date(milis); 
    							ps.setDate(model.getParamIndex(), pDt);
    						}
    				} else {
    					if (model.getParamType() == Types.CHAR && thisParam instanceof String) {
    						if (model.getParamSize() > 0 
    								&& ((String) thisParam).length() > model.getParamSize()) {
    							ps.setString(model.getParamIndex(), ((String) thisParam).substring(0, model.getParamSize()));
    						} else {
    							ps.setString(model.getParamIndex(), ((String) thisParam));
    						}
    					} else if (model.getParamType() == Types.CHAR && thisParam instanceof Character) {
    						ps.setString(model.getParamIndex(), String.valueOf(thisParam));
    					} else if (model.getParamType() == Types.NUMERIC && thisParam instanceof String) {

    						// Format number    	                		
    						String tmp = ((String) thisParam).replaceAll(",", ".");
    						while (tmp.lastIndexOf('.') > 0 && tmp.lastIndexOf('.') > tmp.indexOf('.')) {
    							tmp = tmp.replaceFirst("\\.", "");
    						}

    						if (tmp.trim().length() == 0) {
    		    				logger.trace(model + " = null");
    		    				ps.setNull(model.getParamIndex(), model.getParamType());    							
    						} else {
        						NumberFormat nf = NumberFormat.getInstance(Locale.US);
        						Number nmb = nf.parse(tmp);

        						ps.setBigDecimal(model.getParamIndex(), new BigDecimal(nmb.doubleValue()));
    						}    						
    					} else if (model.getParamType() == Types.BLOB) {
    						// Supports byte [] or String

    						Blob myBlob = ConnectionUtil.createBlob(ConnectionUtil.getInnermostConnection(con));

    						if (myBlob != null) {
    							OutputStream out = myBlob.setBinaryStream(0);
    							if (thisParam instanceof byte[] ) {
    								out.write ((byte[])thisParam);
    							} else {
    								out.write(String.valueOf(thisParam).getBytes());    	                				
    							}
    							out.flush();
    							out.close();
    						}

    						ps.setBlob(model.getParamIndex(), myBlob);

    					} else if (model.getParamType() == Types.CLOB) {
    						// Supports String

    						Clob myClob = ConnectionUtil.createClob(ConnectionUtil.getInnermostConnection(con));

    						if (myClob != null) {
    							Writer writer = myClob.setCharacterStream(0);
    							// Oracle specific
    							// Writer writer = ((oracle.sql.CLOB)myClob).getCharacterOutputStream();   
    							writer.write(String.valueOf(thisParam));
    							writer.flush();
    							writer.close();
    						}

    						ps.setClob(model.getParamIndex(), myClob);

    					} else {    	                		
    						ps.setObject(model.getParamIndex(), thisParam);
    					}
    				}
    			} else {
    				logger.trace(model + " = null");
    				ps.setNull(model.getParamIndex(), model.getParamType());
    			}
    		}
    	}
    }

    /**
     * Retrieve the QueryObj from the model.
     * If the query was modified by some conditional, retrieves the conditional query.
     * If the query was pushed into a batch, retrieves the query at the time.
     * @param queryName Key to identify the query
     * @return Query object containing query
     * @throws DAOException error
     */
    private QueryModel getQuery(String queryName)
    	throws DAOException
    {
		QueryModel queryObj = getModel().getQuery(queryName);
		if (queryObj == null) {
			throw new DAOException("Query not found on DAO : " + queryName);
		}
		if (conditionalQueries != null && conditionalQueries.containsKey(queryName)) {
			queryObj = conditionalQueries.get(queryName);
		}
		
		return queryObj;
    }
    
    /**
     * Fill up the QueryResult based on a resultset
     * @return QueryResult with values 
     * @throws DAOException error
     */
    private QueryResult fillResult(QueryModel queryObj, ResultSet rs) 
    	throws DAOException, SQLException
    {
    	ResultSetMetaData metaData = rs.getMetaData();
    	int numberOfColumns = metaData.getColumnCount();
    	
        QueryResult elemento = new QueryResult();
        
        for (int i=1; i<=numberOfColumns; i++) {
        	ResultModel rModel = queryObj.getResult(i);

        	String columnName = metaData.getColumnName(i);
            if (rModel != null && rModel.getResultName() != null) {
            	columnName = rModel.getResultName();
            }
            int dataType = metaData.getColumnType(i);
            if (rModel != null && rModel.getResultType() != Types.JAVA_OBJECT) {
            	dataType = rModel.getResultType();
            }
            if (dataType == Types.DATE) {
            	elemento.set(columnName,rs.getDate(i));
            } else
            if (dataType == Types.TIMESTAMP) {
            	elemento.set(columnName,rs.getTimestamp(i));
            } else
            if  (dataType == Types.BLOB) {
            	Blob tmpBlob = rs.getBlob(i);            	
                elemento.set(columnName, tmpBlob.getBytes(0, (int) tmpBlob.length()));
            } else
            if  (dataType == Types.CLOB) {
            	Clob tmpClob = rs.getClob(i);
            	elemento.set(columnName, tmpClob.getSubString(0, (int) tmpClob.length()));
            } else {
            	elemento.set(columnName,rs.getObject(i));
            }
        }
        
        return elemento;
    }
    
    /**
     * Basic Query Operation - Several Elements
     *
     * @param query Name of the query defined for the query to be executed
     * @param params object QueryParameter with the parameters for the query
     */
    public Collection<QueryResult> executeQuery(String query, QueryParameter params)
        throws DAOException
    {
		PreparedStatement ps = null;
		ResultSet rs = null;
		ArrayList<QueryResult> col = new ArrayList<QueryResult>();

		QueryModel queryObj = getQuery(query);
		
		String sql = queryObj.getStatement(params.getVariables());
		logger.debug("Executing " + query);
		logger.trace(sql);

		try {
    		if (con == null || con.isClosed()) {
    			con = DataSource.getConnection(getDataSource(), model.getName() , query);
    		}

            ps = con.prepareStatement(sql);

            setParameters(ps, queryObj, params);

            rs = ps.executeQuery();

            while(rs.next()) {
                col.add(fillResult(queryObj, rs));
            }

            setTotalLastQuery(col.size());
            logger.trace("Number of Records : " + getTotalLastQuery());

            return col;

        } catch (SQLException e) {
            logger.error("DataBase Error :",e);
            throw new DAOException("Unexpected Error Query ("+query+") : " + e.getMessage(),"error.DAO.database",e.getMessage());
        } catch (Exception ex) {
            logger.error("Error :",ex);
            throw new DAOException("Unexpected Error Query ("+query+") : " + ex.getMessage(),"error.DAO.database",ex.getMessage());
        } finally {
            try {
                if (rs != null) rs.close();
                if (ps != null) ps.close();
                if (!transactionMode) close();
            } catch (SQLException e) {
            	logger.fatal("error.DAO.database", e);
                throw new DAOException("Unexpected Error Query ("+query+") : " + e.getMessage(),"error.DAO.database",e.getMessage());
            }
        }
    }

    /**
     * Basic Query Operation - Block of several ordered Elements
     *
     * @param query Name of the query defined for the query to be executed
     * @param params object QueryParameter with the parameters for the query
     * @param firstElement first element of the block
     * @param nofElements block size
     */
    public Collection<QueryResult> executeQuery(String query, QueryParameter params, int firstElement, int nofElements)
        throws DAOException
    {
        PreparedStatement ps = null;
        ResultSet rs = null;
        ArrayList<QueryResult> col = new ArrayList<QueryResult>();

		QueryModel queryObj = getQuery(query);

		String sql = queryObj.getStatement(params.getVariables());
		logger.debug("Executing " + query);
        logger.trace(sql);

        try {
    		if (con == null || con.isClosed()) {
    			con = DataSource.getConnection(getDataSource(), model.getName() , query);
    		}

            ps = con.prepareStatement(sql,ResultSet.TYPE_SCROLL_INSENSITIVE,ResultSet.CONCUR_READ_ONLY);

            setParameters(ps, queryObj, params);

            rs = ps.executeQuery();

            if ((rs != null) && (rs.absolute(firstElement))) {

                do {
                    col.add(fillResult(queryObj, rs));                    
                } while(rs.next() && (rs.getRow() < firstElement + nofElements));

                logger.trace("Last retrieved record : " + rs.getRow());
                rs.last();
                setTotalLastQuery(rs.getRow());
                logger.trace("Number of records : " + getTotalLastQuery());
            }

            return col;

        } catch (SQLException e) {
            logger.error("DataBase Error :",e);
            throw new DAOException("Unexpected Error Query ("+query+") : " + e.getMessage(),"error.DAO.database",e.getMessage());
        } catch (Exception ex) {
            logger.error("Error :",ex);
            throw new DAOException("Unexpected Error Query ("+query+") : " + ex.getMessage(),"error.DAO.database",ex.getMessage());
        } finally {
            try {
                if (rs != null) rs.close();
                if (ps != null) ps.close();
                if (!transactionMode) close();
            } catch (SQLException e) {
                throw new DAOException("Unexpected Error Query ("+query+") : " + e.getMessage(),"error.DAO.database",e.getMessage());
            }
        }

    }

    /**
     * Execute query but returns a single result instead of a collection
     * @param query String containing the name of the query to execute
     * @param params object QueryParameter with the parameters for the query
     * @return A QueryResult object
     * @throws DAOException in case of error
     */
    public QueryResult executeQuerySingle(String query, QueryParameter params)
    	throws DAOException
    {
		PreparedStatement ps = null;
		ResultSet rs = null;
        QueryResult result = null;

		QueryModel queryObj = getQuery(query);

		String sql = queryObj.getStatement(params.getVariables());
		logger.debug("Executing " + query);
		logger.trace(sql);

		try {
    		if (con == null || con.isClosed()) {
    			con = DataSource.getConnection(getDataSource(), model.getName() , query);
    		}

            ps = con.prepareStatement(sql);

            setParameters(ps, queryObj, params);

            rs = ps.executeQuery();

            if(rs.next()) {
                result = fillResult(queryObj, rs);
            }

            setTotalLastQuery((result!=null)?1:0);
            logger.trace("Number of records : " + getTotalLastQuery());

            return result;

        } catch (SQLException e) {
            logger.error("DataBase Error :",e);
            throw new DAOException("Unexpected Error Query ("+query+") : " + e.getMessage(),"error.DAO.database",e.getMessage());
        } catch (Exception ex) {
            logger.error("Error :",ex);
            throw new DAOException("Unexpected Error Query ("+query+") : " + ex.getMessage(),"error.DAO.database",ex.getMessage());
        } finally {
            try {
                if (rs != null) rs.close();
                if (ps != null) ps.close();
                if (!transactionMode) close();
            } catch (SQLException e) {
            	logger.fatal("error.DAO.database", e);
                throw new DAOException("Unexpected Error Query ("+query+") : " + e.getMessage(),"error.DAO.database",e.getMessage());
            }
        }
    }

    /**
     * Overwrite of the method in case you don't need parameters for the query
     * @param query name of the query defined
     * @return Collection of QueryResult
     * @throws DAOException
     */
    public Collection<QueryResult> executeQuery(String query)
    	throws DAOException
    {
    	return executeQuery(query, new QueryParameter());
    }

    /**
     * Execute a query
     * @deprecated Use {@link #executeQuery(String, QueryParameter)} instead
     * @param query name of the query defined
     * @param params
     * @return Collection of QueryResult
     * @throws DAOException
     */
    public Collection<QueryResult> executeQuery(String query, Object[] params)
    	throws DAOException
    {
    	QueryParameter qp = new QueryParameter();
    	if (params != null) {
    		for (int i=0; i < params.length; i++) {
    			qp.add(params[i]);
    		}
    	}
    	return executeQuery(query, qp);
    }

    /**
     * Execute a query starting and ending at specific positions in the result set
     * @param query name of the query defined
     * @param firstElement
     * @param nofElements
     * @return Collection of QueryResult
     * @throws DAOException
     */
    public Collection<QueryResult> executeQuery(String query, int firstElement, int nofElements)
    	throws DAOException
    {
    	return executeQuery(query, new QueryParameter(), firstElement, nofElements);
    }

    /**
     * Execute a query starting and ending at specific positions in the result set 
     * @deprecated Use @link #executeQuery(String, QueryParameter, int, int) instead
     * @param query name of the query defined
     * @param params
     * @param firstElement
     * @param nofElements
     * @return Collection of QueryResult
     * @throws DAOException
     */
    public Collection<QueryResult> executeQuery(String query, Object[] params, int firstElement, int nofElements)
		throws DAOException
   	{
    	QueryParameter qp = new QueryParameter();
    	if (params != null) {
    		for (int i=0; i < params.length; i++) {
    			qp.add(params[i]);
    		}
    	}
    	return executeQuery(query, qp, firstElement, nofElements);
   	}
    
    /**
     * Execute a query returning a single result
     * @param query name of the query defined
     * @return QueryResult
     * @throws DAOException
     */
    public QueryResult executeQuerySingle(String query)
    	throws DAOException
    {
    	return executeQuerySingle(query, new QueryParameter());
    }

    /**
     * Execute a query returning a single result
     * @deprecated Use @link #executeQuerySingle(String, QueryParameter) instead
     * @param query name of the query defined
     * @return QueryResult
     * @throws DAOException
     */
    public QueryResult executeQuerySingle(String query, Object[] params)
    	throws DAOException
    {
    	QueryParameter qp = new QueryParameter();
    	if (params != null) {
    		for (int i=0; i < params.length; i++) {
    			qp.add(params[i]);
    		}
    	}
    	return executeQuerySingle(query, qp);
    }

    /**
     * Method to execute update, insert and delete operation
     * @param queryObj query object
     * @param params parameters
     * @return int number of updated rows
     * @throws DAOException
     */
    private int executeUpdate(QueryModel queryObj, QueryParameter params)
    	throws DAOException
    {
		PreparedStatement ps = null;
		String sql = queryObj.getStatement(params!=null?params.getVariables():null);
		logger.debug("Executing " + queryObj.getName() );
		logger.trace(sql);

		try {
			if (con == null || con.isClosed()) {
				con = DataSource.getConnection(getDataSource(), model.getName() ,queryObj.getName());
			}

			ps = con.prepareStatement(sql);

            setParameters(ps, queryObj, params);

			return ps.executeUpdate();

		} catch (SQLException e) {
			logger.error("DataBase Error :", e);
			if (transactionMode) rollback();
			throw new DAOException("Unexpected Error Query ("+queryObj.getName()+") : " + e.getMessage(),"error.DAO.database", e.getMessage());
		} catch (Exception ex) {
			logger.error("Error :", ex);
			if (transactionMode) rollback();
			throw new DAOException("Unexpected Error Query ("+queryObj.getName()+") : " + ex.getMessage(),"error.DAO.database", ex.getMessage());
		} finally {
			try {
				if (!transactionMode) commit();
				if (ps != null)       ps.close();
				if (!transactionMode) close();
			} catch (SQLException e) {
				throw new DAOException("Unexpected Error Query ("+queryObj.getName()+") : " + e.getMessage(),"error.DAO.database", e.getMessage());
			}
		}
    }
    
    /**
     * Method to execute update, insert and delete operation
     * @param query query name
     * @param params parameters
     * @return int number of updated rows
     * @throws DAOException
     */
    public int executeUpdate(String query, QueryParameter params)
			throws DAOException 
	{
		QueryModel queryObj = getQuery(query);

		return executeUpdate(queryObj, params);
	}

    /**
     * Execute update, insert and delete operation
     * @param query
     * @return number of successful updates
     * @throws DAOException
     */
    public int executeUpdate(String query) 
    	throws DAOException
    {
    	return executeUpdate(query, new QueryParameter());
    }
    
    /**
     * Execute update, insert and delete operation
     * @deprecated Use @link #executeUpdate(String, QueryParameter) instead
     * @param query
     * @param params
     * @return number of successful updates
     * @throws DAOException
     */
    public int executeUpdate(String query, Object[] params)
		throws DAOException
	{
    	QueryParameter qp = new QueryParameter();
    	if (params != null) {
    		for (int i=0; i < params.length; i++) {
    			qp.add(params[i]);
    		}
    	}
    	return executeUpdate(query, qp);
    }
    
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // Transactions 
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------

    
    /**
     * The transaction mode of the DAO 
	 * @return Returns the transactionMode.
	 */
	public boolean isTransactionMode() {
		return transactionMode;
	}
	
	/**
	 * If transactionMode is set to true, it means that the DAO will NOT close
	 * the connection after the statements, and will take care of rollbacks.
	 * However, you must commit the connection at the end of your transaction.
	 * @param transactionMode The transactionMode to set.
	 */
	public void setTransactionMode(boolean transactionMode) {
		this.transactionMode = transactionMode;
		if (transactionMode) {
			try {
				if (con == null || con.isClosed()) {
					con = DataSource.getConnection(getDataSource(), model.getName(), "EFREET (setTransactionMode)");
				}
			} catch (Exception e) {
				close();
			}
			try {
		    	if (con.getAutoCommit()) {
		    		con.setAutoCommit(false);
		    	}
			} catch (Exception e) {
				logger.error("Cant change auto commit flag", e);
			}			
		} else {
			// Commit and close the connection
			try {
				commit();
			} catch (Exception e) {
				close();
			}
		}
	}
	
	/**
	 * Allows a DAO to share a connection with another DAO in transaction mode
	 * The primary DAO must be in transaction mode
	 * @param primaryDao
	 */
	public void shareTransaction(DataAccessObject primaryDao) {
		
		if (primaryDao != null && primaryDao.isTransactionMode()) {
			close();
			setConnection(primaryDao.getConnection());
			setTransactionMode(true);
		}
		
	}
	
	/**
     * Commit the transaction
     * Automatically closes the connection to prevent connection leak
     */
    public boolean commit()
        throws SQLException, DAOException
    {
        try {
            if ((this.con == null) || (this.con.isClosed())) return false;
            if (!con.getAutoCommit()) this.con.commit();
            return true;
        } catch(SQLException e) {
            logger.error("Commit Error : ",e);
            return false;
        } finally {
        	close();
        }
    }

    /**
     * Rollback on the transaction. Since this method is supposed to
     * be called often from inside catch statements, it does not throws
     * an exception , instead it returns false if something went wrong.
     * Automatically closes the connection to prevent connection leak
     */
    public boolean rollback()
    {
        try {
            if ((this.con == null) || (this.con.isClosed())) return false;
            this.con.rollback();
            return true;
        } catch(SQLException e) {
            logger.error("Rollback Error : ",e);
            return false;
        } finally {
        	close();
        }
    }

    /**
     * Close current connection, these method is supposed to be called if you
     * set the transaction mode to true.
     * @return true if the connection is successfully closed
     */
    public boolean close() 
    {
        try {
            if ((this.con == null) || (this.con.isClosed())) return false;
			try {
		    	if (con !=null && !con.getAutoCommit()) {
		    		con.setAutoCommit(true);
		    	}
			} catch (Exception e) {
				logger.error("Cant change auto commit flag", e);
			}			            
            this.con.close();
            return true;
        } catch(SQLException e) {
            logger.error("Connection Close Error : ",e);
            return false;
        }
    }
    
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // Conditional Queries
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------

    /**
     * Appends a conditional query to the end of a query
     * @param queryName query name
     * @param conditional conditional name
     */
    public void appendConditionalToQuery(String queryName, String conditional) {
    	appendConditionalToQuery(queryName, conditional, null);
    }
    	
    public void appendConditionalToQuery(String queryName, String conditional, QueryParameter condtParameters) {
    	
    	QueryModel query = getModel().getQuery(queryName);
    	
    	if (conditionalQueries != null && conditionalQueries.containsKey(queryName)) {
    		query = conditionalQueries.get(queryName);
    	}
    	
    	QueryModel condt = getModel().getQuery(conditional);
    	
    	if (query != null && condt != null) {
    		try {
    			query = query.clone();
    			condt = condt.clone();
    		} catch (CloneNotSupportedException e) {
				query = null;
				condt = null;
			}
    	}
    	
    	if (query != null && condt != null) {
    		if (conditionalQueries == null) {
    			conditionalQueries = new HashMap<String, QueryModel>();
    		}
    		String qStatement = query.getStatement();
    		String cStatement = condt.getStatement();
    		if (qStatement != null && cStatement != null) {
    			query.setStatement(qStatement.concat(" ".concat(cStatement)));
    		}
    		
    		int qParametersSize = query.parameterSize();
    		SortedSet<ParameterModel> cParameters = condt.getParameters();
    		if (cParameters != null) {
    			Iterator<ParameterModel> iter = cParameters.iterator();
    			while (iter != null && iter.hasNext()) {
    				ParameterModel o = iter.next();
    				if (o != null) {
    					o.setParamIndex(o.getParamIndex() + qParametersSize);
    					if (condtParameters != null) {
    						o.setStaticValue(condtParameters.get(o.getParamName()));
    					}
    					query.addParameter(o);
    				}
    			}
    		}
    		conditionalQueries.put(query.getName(), query);
    	}    		
    }
    
    /**
     * Removes the conditional appends for this query
     * @param queryName name of the query 
     */
    public void resetConditionalQuery(String queryName) {
    	if (conditionalQueries != null && queryName != null) {
    		conditionalQueries.remove(queryName);
    	}
    }
    
    /**
     * Removes all conditional queries for all queries
     */
    public void resetAllConditionals() {
    	if (conditionalQueries != null) {
    		conditionalQueries.clear();
    	}
    }
    
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // Batch Statements 
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    // ----------------------------------------------------------------------
    /**
     * Add a query to a batch of statements to be processed
     * @param queryName Query descriptor
     */
    public void addBatch(String queryName) {
    	addBatch(queryName, null);
    }
    
    /**
     * Add a query to a batch of statements with its parameters
     * @param queryName
     * @param params
     */
    public void addBatch(String queryName, QueryParameter params) {

    	if (batchQueries == null) {
    		batchQueries = new ArrayList<QueryInBatch>();
    	}

    	QueryInBatch qryWparam = new QueryInBatch();
    	qryWparam.setQueryName(queryName);
    	qryWparam.setParameters(params);

    	try {
    		QueryModel queryObj = getQuery(queryName);
    		qryWparam.setQuery(queryObj);
    	} catch (Exception e) {
			logger.error("Batch Error : ",e);
		}
    	
    	batchQueries.add(qryWparam);
    }
    
    /**
     * Clear the batch of statements to be executed
     */
    public void clearBatch() {
    	if (batchQueries != null) {
    		batchQueries.clear();
    	}
    }
    
    /**
     * Execute a batch of statements sequentially in the same transaction
     * @throws DAOException error
     */
    public int[] executeBatch() throws DAOException {
    	return executeBatch(0);
    }

    /**
     * Execute a batch of statements sequentially in the same transaction
     * WARNING - This method doesn't guarantee integrity since a commit will
     * be made at each check point defined by the number of transactions
     * executed so far.
     * @param commitPoint number of updates to be executed before a commit check, 
     *        a 0 is interpreted as no commit point 
     * @throws DAOException error
     */
    public int[] executeBatch(int commitPoint) throws DAOException {

    	ArrayList<Integer> respArray = new ArrayList<Integer>();

    	int checkPoint = 0;
    	boolean prevTransMode = this.transactionMode;
		setTransactionMode(true);
    	if (batchQueries != null && !batchQueries.isEmpty()) {
    		Iterator<QueryInBatch> iterQry = batchQueries.iterator();
    		while (iterQry != null && iterQry.hasNext()) {
    			QueryInBatch qryToBeExec = (QueryInBatch) iterQry.next();
    			int result = executeUpdate(qryToBeExec.getQuery(), qryToBeExec.getParameters());
    			respArray.add(new Integer(result));
    			// Partial commit
    			checkPoint++;
    			if (commitPoint > 0 && checkPoint >= commitPoint) {
    				try {
    					commit();
    					checkPoint = 0;
    				} catch (SQLException e) {
    					rollback();
    					setTransactionMode(prevTransMode);
    					throw new DAOException("Unexpected Error Batch on commit : " + e.getMessage(),"error.DAO.database", e.getMessage());
					}
    			}
    		}
    	}
    	if (!prevTransMode || commitPoint > 0) { 
	    	try {
	    		commit();
			} catch (SQLException e) {
				rollback();
				setTransactionMode(prevTransMode);
				throw new DAOException("Unexpected Error Batch on commit : " + e.getMessage(),"error.DAO.database", e.getMessage());
			}
    	}
		setTransactionMode(prevTransMode);
    	
    	// Converting Array list to int[]
    	int[] resp = new int[respArray.size()];
    	for (int r=0; r < respArray.size(); r++) {
    		resp[r] = ((Integer) respArray.get(r)).intValue();
    	}
    	return resp;
    }
    
}
